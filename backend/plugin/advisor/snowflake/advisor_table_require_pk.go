// Package snowflake is the advisor for snowflake database.
package snowflake

import (
	"fmt"

	"github.com/antlr4-go/antlr/v4"
	parser "github.com/bytebase/snowsql-parser"

	"github.com/bytebase/bytebase/backend/plugin/advisor"
	"github.com/bytebase/bytebase/backend/plugin/advisor/db"
)

var (
	_ advisor.Advisor = (*TableRequirePkAdvisor)(nil)
)

func init() {
	advisor.Register(db.Snowflake, advisor.SnowflakeTableRequirePK, &TableRequirePkAdvisor{})
}

// TableRequirePkAdvisor is the advisor checking for table require primary key.
type TableRequirePkAdvisor struct {
}

// Check checks for table require primary key.
func (*TableRequirePkAdvisor) Check(ctx advisor.Context, statement string) ([]advisor.Advice, error) {
	tree, errAdvice := parseStatement(statement)
	if errAdvice != nil {
		return errAdvice, nil
	}

	level, err := advisor.NewStatusBySQLReviewRuleLevel(ctx.Rule.Level)
	if err != nil {
		return nil, err
	}

	listener := &tableRequirePkChecker{
		currentConstraintAction: currentConstraintActionNone,
		level:                   level,
		title:                   string(ctx.Rule.Type),
		tableHasPrimaryKey:      make(map[string]bool),
		tableOriginalName:       make(map[string]string),
	}

	antlr.ParseTreeWalkerDefault.Walk(listener, tree)

	return listener.generateAdvice()
}

// currentConstraintAction is the action of current constraint.
type currentConstraintAction int

const (
	currentConstraintActionNone currentConstraintAction = iota
	currentConstraintActionAdd
	currentConstraintActionDrop
)

// tableRequirePkChecker is the listener for table require primary key.
type tableRequirePkChecker struct {
	*parser.BaseSnowflakeParserListener

	level advisor.Status
	title string

	adviceList []advisor.Advice

	currentConstraintAction currentConstraintAction
	// currentNormalizedTableName is the current table name, and it is normalized.
	// It should be set then entering create_table, alter_table and so on,
	// and should be reset then exiting them.
	currentNormalizedTableName string

	// tableHasPrimaryKey is a map of normalized table name to whether the table has primary key.
	tableHasPrimaryKey map[string]bool
	// tableOriginalName is a map of normalized table name to original table name.
	// The key of the tableHasPrimaryKey and tableOriginalName is the same.
	tableOriginalName map[string]string
}

// generateAdvice returns the advices generated by the listener, the advices must not be empty.
func (l *tableRequirePkChecker) generateAdvice() ([]advisor.Advice, error) {
	for tableName, has := range l.tableHasPrimaryKey {
		if !has {
			l.adviceList = append(l.adviceList, advisor.Advice{
				Status:  l.level,
				Code:    advisor.TableNoPK,
				Title:   l.title,
				Content: fmt.Sprintf("Table %s requires PRIMARY KEY.", l.tableOriginalName[tableName]),
			})
		}
	}
	if len(l.adviceList) == 0 {
		return []advisor.Advice{
			{
				Status:  advisor.Success,
				Code:    advisor.Ok,
				Title:   "OK",
				Content: "",
			},
		}, nil
	}
	return l.adviceList, nil
}

// EnterCreate_table is called when production create_table is entered.
func (l *tableRequirePkChecker) EnterCreate_table(ctx *parser.Create_tableContext) {
	originalTableName := ctx.Object_name().GetText()
	normalizedTableName := normalizeIdentifierName(originalTableName)

	l.tableHasPrimaryKey[normalizedTableName] = false
	l.tableOriginalName[normalizedTableName] = originalTableName
	l.currentNormalizedTableName = normalizedTableName
	l.currentConstraintAction = currentConstraintActionAdd
}

// ExitCreate_table is called when production create_table is exited.
func (l *tableRequirePkChecker) ExitCreate_table(ctx *parser.Create_tableContext) {
	l.currentNormalizedTableName = ""
	l.currentConstraintAction = currentConstraintActionNone
}

// EnterInline_constraint is called when production inline_constraint is entered.
func (l *tableRequirePkChecker) EnterInline_constraint(ctx *parser.Inline_constraintContext) {
	if ctx.PRIMARY() == nil {
		return
	}
	l.tableHasPrimaryKey[l.currentNormalizedTableName] = true
}

func (l *tableRequirePkChecker) EnterOut_of_line_constraint(ctx *parser.Out_of_line_constraintContext) {
	if ctx.PRIMARY() == nil || l.currentNormalizedTableName == "" || l.currentConstraintAction == currentConstraintActionNone {
		return
	}
	if l.currentConstraintAction == currentConstraintActionAdd {
		l.tableHasPrimaryKey[l.currentNormalizedTableName] = true
	} else {
		l.tableHasPrimaryKey[l.currentNormalizedTableName] = false
	}
}

// // EnterCreate_table is called when production create_table is entered.
// func (l *tableRequirePkChecker) EnterCreate_table(ctx *parser.Create_tableContext) {
// 	anyPrimaryKey := false
// 	tableName := normalizeIdentifierName(ctx.Object_name().GetText())

// 	//TODO(zp): split the following logic into EnterCreate_table, Enter_Full_col_decl and so on to improve the performance.
// 	columnDeclItemListContext := ctx.Column_decl_item_list()
// 	for _, declItem := range columnDeclItemListContext.AllColumn_decl_item() {
// 		if anyPrimaryKey {
// 			break
// 		}
// 		if fullColDeclContext := declItem.Full_col_decl(); fullColDeclContext != nil {
// 			for _, inlineConstraintContext := range fullColDeclContext.AllInline_constraint() {
// 				if inlineConstraintContext.PRIMARY() != nil {
// 					anyPrimaryKey = true
// 					break
// 				}
// 			}
// 		} else if outOfLineConstraintContext := declItem.Out_of_line_constraint(); outOfLineConstraintContext != nil {
// 			if outOfLineConstraintContext.PRIMARY() != nil {
// 				anyPrimaryKey = true
// 				break
// 			}
// 		}
// 	}

// 	if !anyPrimaryKey {
// 		l.adviceList = append(l.adviceList, advisor.Advice{
// 			Status:  l.level,
// 			Code:    advisor.TableNoPK,
// 			Title:   l.title,
// 			Content: fmt.Sprintf("Table %s requires PRIMARY KEY.", tableName),
// 			Line:    ctx.GetStart().GetLine(),
// 		})
// 	}
// }
