import { flattenTaskList } from "@/components/Issue/logic";
import { TemplateType } from "@/plugins";
import { useEnvironmentStore } from "@/store";
import {
  IssueCreate,
  IssueType,
  MigrationType,
  MigrationContext,
  TaskCreate,
} from "@/types";
import {
  findProject,
  BuildNewIssueContext,
  VALIDATE_ONLY_SQL,
  findDatabaseListByQuery,
} from "../common";
import { IssueCreateHelper } from "./helper";

export const maybeBuildTenantDeployIssue = async (
  context: BuildNewIssueContext
): Promise<IssueCreate | undefined> => {
  const { route } = context;
  if (route.query.mode !== "tenant") {
    return undefined;
  }

  const project = await findProject(context);
  const issueType = route.query.template as IssueType;
  const isMigrate =
    issueType === "bb.issue.database.schema.update" ||
    issueType === "bb.issue.database.data.update";
  if (project.tenantMode === "TENANT" && isMigrate) {
    // Only to build tenant issue when:
    // 1. Project is tenant mode.
    // 2. Is schema update or data update (no to establish baseline).
    return buildNewTenantSchemaUpdateIssue(context);
  }
  return undefined;
};

const buildNewTenantSchemaUpdateIssue = async (
  context: BuildNewIssueContext
): Promise<IssueCreate> => {
  const { route } = context;
  const helper = new IssueCreateHelper(context);

  await helper.prepare();
  // tenant issue is generated by specifying databaseName
  const templateType = route.query.template as TemplateType;
  let migrationType: MigrationType = "MIGRATE";
  if (templateType === "bb.issue.database.data.update") {
    migrationType = "DATA";
  }

  const databaseList = findDatabaseListByQuery(context);
  if (databaseList.length > 0) {
    // For multi-selection pipeline, pass databaseId accordingly.
    helper.issueCreate!.createContext = {
      detailList: databaseList.map((db) => {
        return {
          migrationType: migrationType,
          databaseId: db.id,
          statement: VALIDATE_ONLY_SQL,
          earliestAllowedTs: 0,
        };
      }),
    };
  } else {
    // For tenant deployment config pipeline, omit databaseId
    helper.issueCreate!.createContext = {
      detailList: [
        {
          migrationType: migrationType,
          statement: VALIDATE_ONLY_SQL,
          earliestAllowedTs: 0,
        },
      ],
    };
  }
  await helper.validate();

  // we are setting SQL statement to "" because showing /* YOUR_SQL_HERE */
  // is not that friendly to users
  // setting it to empty can provide a placeholder to user, along with an
  // exclamation mark indicating "No SQL statement"
  const createContext = helper.issueCreate!.createContext as MigrationContext;
  for (const detail of createContext.detailList) {
    detail.statement = "";
  }

  const issueCreate = await helper.generate();

  // Setup rollbackEnabled if needed
  if (templateType === "bb.issue.database.data.update") {
    const environmentStore = useEnvironmentStore();
    const hasProductionEnvironment = issueCreate.pipeline?.stageList.some(
      (stage) => {
        return (
          environmentStore.getEnvironmentById(stage.environmentId).tier ===
          "PROTECTED"
        );
      }
    );
    // Due to the limitation of issueCreate.createContext, all tasks in an issue
    // using tenant mode will share ONE rollbackEnabled value in the creating
    // phase.
    // Once the issue is successfully created, the rollbackEnabled field goes
    // to task.payload. Then they can be turned on/off separately.
    if (hasProductionEnvironment) {
      const context = issueCreate.createContext as MigrationContext;
      context.detailList.forEach((detail) => {
        detail.rollbackEnabled = true;
      });
      flattenTaskList<TaskCreate>(issueCreate).forEach((task) => {
        task.rollbackEnabled = true;
      });
    }
  }
  return issueCreate;
};
